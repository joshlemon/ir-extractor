#!/usr/bin/env python


from __future__ import print_function
from optparse import OptionParser
import hashlib, zipfile, os.path, datetime
try:
    import zlib
    compression = zipfile.ZIP_DEFLATED
except:
    print('WARNING: Do not appear that you have zlib installed')
    compression = zipfile.ZIP_STORED
try:
    import pyminizip
except:
    print('ERROR: Do not appear that you have pyminizip installed')
    print('ERROR: Run the following commend on your machine')
    print('ERROR: sudo pip install pyminizip')


__description__ = "Python tool for protecting malware samples and capturing meta-data."
__author__ = 'Josh Lemon'
__version__ = '0.0.1'
__date__ = '2018/08/05'


"""
Source code put in public domain by Josh Lemon
https://www.joshlemon.com.au
Use at your own risk

This python script uses the pyminizip moduel from https://github.com/smihica/pyminizip

History:
  2018/08/05: 0.0.1 first release

Todo:
  Add the ability to add multiple files at once to a ZIP file.

"""


def sha1hashfile(file):
    
    sha1 = hashlib.sha1()
    
    while True:
        data = file.read(128)
        if not data:
            break
        sha1.update(data)
    
    return sha1.hexdigest()


def print_info(archive_name):
    with zipfile.ZipFile(archive_name) as zf:
        for info in zf.infolist():
            print('  Files              :',info.filename)
            print('  Comment            :', info.comment)
            mod_date = datetime.datetime(*info.date_time)
            print('  Modified           :', mod_date)
            if info.create_system == 0:
                system = 'Windows'
            elif info.create_system == 3:
                system = 'Unix'
            else:
                system = 'UNKNOWN'
            print('  System             :', system)
            print('  ZIP version        :', info.create_version)
            print('  Compressed         :', info.compress_size, 'bytes')
            print('  Uncompressed       :', info.file_size, 'bytes')
            if info.compress_type == 0:
                datatype = 'Stored'
            elif info.compress_type == 8:
                datatype = 'Defalted'
            elif info.compress_type == 12:
                datatype = 'BZIP2'
            elif info.compress_type == 14:
                datatype = 'LZMA'
            else:
                datatype = 'UNKNOWN'
            print('  Compression Type   :', datatype)
            print()


def zipupfile(inputfile):
    filehash = sha1hashfile(inputfile)
    modes = {zipfile.ZIP_DEFLATED: 'deflated', zipfile.ZIP_STORED: 'stored',}
    
    if os.path.exists(filehash+'.zip'):
        print('ERROR: A ZIP file already exists in this director with the resulting SHA1 hash.')
    else:
        with zipfile.ZipFile(filehash+'.zip',mode='w') as zf:
            try:
                zf.write(inputfile.name, compress_type=compression)
            finally:
                zf.close()
    return


def protectfile(inputfile, password):
    filehash = sha1hashfile(inputfile)
    if os.path.exists(filehash+'.zip'):
        print('ERROR: A ZIP file already exists in this director with the resulting SHA1 hash.')
    else:
        try:
            if password:
                pyminizip.compress(inputfile.name, '', filehash+'.zip', password, 0)
            else:
                pyminizip.compress(inputfile.name, '', filehash+'.zip', "infected", 0)
        except:
            print('ERROR: An error occured trying to protect the file.')
    
    return


def unprotectfile(inputfile, password):
    if os.path.exists(inputfile[:-4]):
        print('ERROR: There is already a folder in this directory with the name: '+inputfile[:-4])
    else:
        os.makedirs(inputfile[:-4])
        try:
            if password:
                pyminizip.uncompress(inputfile, password, inputfile[:-4], True)
            else:
                pyminizip.uncompress(inputfile, "infected", inputfile[:-4], True)
        except:
            print('ERROR: An error occured trying to extract the file.')
    return


def main():
    parser=OptionParser(usage='usage: %prog [options]\n' + __description__, version='%prog ' + __version__)
    parser.add_option('-m', '--man', action='store_true', default=False, help='Print manual')
    parser.add_option('-u','--unprotect', dest="safefile", help='Unprotect a file that has been protected with this script', metavar="FILE")
    parser.add_option('-i', '--info', dest="infofilename", help='Display information about a protected ZIP FILE', metavar="FILE")
    parser.add_option('-p', '--protect', dest="password", help='Provide the ability to specify a password to protect the ZIP file', metavar="PASSWORD")
    parser.add_option('-s', '--sample', dest="malwarefile", help='Provide the file you want to be password protected in a ZIP file', metavar="FILE")
    parser.add_option('-z', '--ziponly', dest="ziponlyfile", help='ZIP up a file with no password protection', metavar="FILE")
    (options, args)=parser.parse_args()

    if options.man:
        parser.print_help()
        return
    
    if options.safefile:
        unprotectfile(options.safefile, options.password)
    if options.infofilename:
        print_info(options.infofilename)
    if options.malwarefile:
        protectfile(open(options.malwarefile, 'r'), options.password)
    if options.ziponlyfile:
        zipupfile(open(options.ziponlyfile, 'r'))
    elif not options.malwarefile and not options.infofilename and not options.safefile and not options.ziponlyfile:
       parser.print_help()
    return


if __name__ == '__main__':
    main()
